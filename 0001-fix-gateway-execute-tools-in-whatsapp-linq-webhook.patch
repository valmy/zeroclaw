From b3b1f7089eb498fea2fea597939ebc31d0c0f8fa Mon Sep 17 00:00:00 2001
From: "T. Budiman" <tbudiman@gmail.com>
Date: Fri, 20 Feb 2026 02:44:54 +0700
Subject: [PATCH] fix(gateway): execute tools in WhatsApp/Linq/webhook
 endpoints

Tool calls were being displayed as raw XML tags in WhatsApp/Linq gateway
channels instead of being executed. This was because gateway handlers used
`run_gateway_chat_with_multimodal` which directly calls the provider without
processing tool calls, unlike normal channels which use `run_tool_call_loop`.

Changes:
- Add `security`, `runtime`, and `tools_registry` fields to `AppState`
- Add `run_gateway_tool_loop` function that uses `run_tool_call_loop` for
  proper tool execution
- Update `handle_webhook`, `handle_whatsapp_message`, and
  `handle_linq_webhook` to use `run_gateway_tool_loop`
- Add `MockRuntime` for gateway tests
- Update all test helpers to include new `AppState` fields

Fixes behavior where tool call XML like `<file_read><path>SOUL.md</path></file_read>`
was displayed to users instead of executing the tool and returning results.

Co-Authored-By: Claude Opus 4.6 <noreply@anthropic.com>
---
 src/gateway/mod.rs | 334 +++++++++++++++++++++++++++------------------
 1 file changed, 204 insertions(+), 130 deletions(-)

diff --git a/src/gateway/mod.rs b/src/gateway/mod.rs
index 2f56909..89b13c5 100644
--- a/src/gateway/mod.rs
+++ b/src/gateway/mod.rs
@@ -7,6 +7,7 @@
 //! - Request timeouts (30s) to prevent slow-loris attacks
 //! - Header sanitization (handled by axum/hyper)
 
+use crate::agent::loop_::run_tool_call_loop;
 use crate::channels::{Channel, LinqChannel, SendMessage, WhatsAppChannel};
 use crate::config::Config;
 use crate::memory::{self, Memory, MemoryCategory};
@@ -283,6 +284,12 @@ pub struct AppState {
     pub linq_signing_secret: Option<Arc<str>>,
     /// Observability backend for metrics scraping
     pub observer: Arc<dyn crate::observability::Observer>,
+    /// Security policy for tool execution
+    pub security: Arc<SecurityPolicy>,
+    /// Runtime adapter for tool execution
+    pub runtime: Arc<dyn runtime::RuntimeAdapter>,
+    /// Tools registry for agent tool execution
+    pub tools_registry: Arc<Vec<Box<dyn tools::Tool>>>,
 }
 
 /// Run the HTTP gateway using axum with proper HTTP/1.1 compliance.
@@ -343,10 +350,10 @@ pub async fn run_gateway(host: &str, port: u16, config: Config) -> Result<()> {
         (None, None)
     };
 
-    let _tools_registry = Arc::new(tools::all_tools_with_runtime(
+    let tools_registry = Arc::new(tools::all_tools_with_runtime(
         Arc::new(config.clone()),
         &security,
-        runtime,
+        runtime.clone(),
         Arc::clone(&mem),
         composio_key,
         composio_entity_id,
@@ -522,6 +529,9 @@ pub async fn run_gateway(host: &str, port: u16, config: Config) -> Result<()> {
         linq: linq_channel,
         linq_signing_secret,
         observer,
+        security,
+        runtime,
+        tools_registry,
     };
 
     // Build router with middleware
@@ -712,6 +722,59 @@ async fn run_gateway_chat_with_multimodal(
         .await
 }
 
+/// Run gateway chat with full tool execution support (like normal channels).
+/// This replaces `run_gateway_chat_with_multimodal` for endpoints that need tool support.
+async fn run_gateway_tool_loop(state: &AppState, provider_label: &str, message: &str) -> anyhow::Result<String> {
+    // Extract tool names and descriptions for the system prompt
+    let tools: Vec<(&str, &str)> = state
+        .tools_registry
+        .iter()
+        .map(|tool| (tool.name(), tool.description()))
+        .collect();
+
+    // Build system prompt with workspace context AND tools
+    let system_prompt = {
+        let config_guard = state.config.lock();
+        crate::channels::build_system_prompt(
+            &config_guard.workspace_dir,
+            &state.model,
+            &tools,
+            &[], // skills
+            Some(&config_guard.identity),
+            None, // bootstrap_max_chars - use default
+        )
+    };
+
+    // Build initial message history with system prompt and user message
+    let mut history = vec![
+        ChatMessage::system(system_prompt),
+        ChatMessage::user(message),
+    ];
+
+    // Get multimodal config from state
+    let multimodal_config = state.config.lock().multimodal.clone();
+    let max_tool_iterations = state.config.lock().agent.max_tool_iterations;
+
+    // Run the tool call loop - this will execute tools and return only the final text response
+    run_tool_call_loop(
+        state.provider.as_ref(),
+        &mut history,
+        state.tools_registry.as_ref(),
+        state.observer.as_ref(),
+        provider_label,
+        &state.model,
+        state.temperature,
+        true, // silent - no extra output
+        None, // approval - not used for gateway
+        "gateway",
+        &multimodal_config,
+        max_tool_iterations,
+        None, // cancellation_token
+        None, // on_delta - no streaming support in gateway yet
+    )
+    .await
+}
+
 /// Webhook request body
 #[derive(serde::Deserialize)]
 pub struct WebhookBody {
@@ -833,7 +896,7 @@ async fn handle_webhook(
             messages_count: 1,
         });
 
-    match run_gateway_chat_with_multimodal(&state, &provider_label, message).await {
+    match run_gateway_tool_loop(&state, &provider_label, message).await {
         Ok(response) => {
             let duration = started_at.elapsed();
             state
@@ -1039,7 +1102,7 @@ async fn handle_whatsapp_message(
                 .await;
         }
 
-        match run_gateway_chat_with_multimodal(&state, &provider_label, &msg.content).await {
+        match run_gateway_tool_loop(&state, &provider_label, &msg.content).await {
             Ok(response) => {
                 // Send reply via WhatsApp
                 if let Err(e) = wa
@@ -1152,8 +1215,8 @@ async fn handle_linq_webhook(
                 .await;
         }
 
-        // Call the LLM
-        match run_gateway_chat_with_multimodal(&state, &provider_label, &msg.content).await {
+        // Call the LLM with tool support
+        match run_gateway_tool_loop(&state, &provider_label, &msg.content).await {
             Ok(response) => {
                 // Send reply via Linq
                 if let Err(e) = linq
@@ -1199,6 +1262,91 @@ mod tests {
         hex::encode(bytes)
     }
 
+    /// Create a minimal `AppState` for tests, including new tool support fields.
+    fn test_app_state() -> AppState {
+        let config = Config::default();
+        let runtime: Arc<dyn runtime::RuntimeAdapter> = Arc::new(MockRuntime);
+        let security = Arc::new(SecurityPolicy::from_config(
+            &config.autonomy,
+            &config.workspace_dir,
+        ));
+        let tools_registry: Arc<Vec<Box<dyn tools::Tool>>> = Arc::new(vec![]);
+        AppState {
+            config: Arc::new(Mutex::new(config)),
+            provider: Arc::new(MockProvider::default()),
+            model: "test-model".into(),
+            temperature: 0.0,
+            mem: Arc::new(MockMemory),
+            auto_save: false,
+            webhook_secret_hash: None,
+            pairing: Arc::new(PairingGuard::new(false, &[])),
+            trust_forwarded_headers: false,
+            rate_limiter: Arc::new(GatewayRateLimiter::new(100, 100, 100)),
+            idempotency_store: Arc::new(IdempotencyStore::new(Duration::from_secs(300), 1000)),
+            whatsapp: None,
+            whatsapp_app_secret: None,
+            linq: None,
+            linq_signing_secret: None,
+            observer: Arc::new(crate::observability::NoopObserver),
+            security,
+            runtime,
+            tools_registry,
+        }
+    }
+
+    /// Override specific fields in a test `AppState`.
+    fn test_app_state_with_observer(observer: Arc<dyn crate::observability::Observer>) -> AppState {
+        let mut state = test_app_state();
+        state.observer = observer;
+        state
+    }
+
+    /// Create a test `AppState` with custom provider and memory.
+    fn test_app_state_with_provider_and_memory(
+        provider: Arc<dyn Provider>,
+        memory: Arc<dyn Memory>,
+    ) -> AppState {
+        let config = Config::default();
+        let runtime: Arc<dyn runtime::RuntimeAdapter> = Arc::new(MockRuntime);
+        let security = Arc::new(SecurityPolicy::from_config(
+            &config.autonomy,
+            &config.workspace_dir,
+        ));
+        let tools_registry: Arc<Vec<Box<dyn tools::Tool>>> = Arc::new(vec![]);
+        AppState {
+            config: Arc::new(Mutex::new(config)),
+            provider,
+            model: "test-model".into(),
+            temperature: 0.0,
+            mem: memory,
+            auto_save: false,
+            webhook_secret_hash: None,
+            pairing: Arc::new(PairingGuard::new(false, &[])),
+            trust_forwarded_headers: false,
+            rate_limiter: Arc::new(GatewayRateLimiter::new(100, 100, 100)),
+            idempotency_store: Arc::new(IdempotencyStore::new(Duration::from_secs(300), 1000)),
+            whatsapp: None,
+            whatsapp_app_secret: None,
+            linq: None,
+            linq_signing_secret: None,
+            observer: Arc::new(crate::observability::NoopObserver),
+            security,
+            runtime,
+            tools_registry,
+        }
+    }
+
+    /// Create a test `AppState` with custom provider, memory, and webhook secret hash.
+    fn test_app_state_with_provider_memory_and_secret(
+        provider: Arc<dyn Provider>,
+        memory: Arc<dyn Memory>,
+        webhook_secret_hash: Option<Arc<str>>,
+    ) -> AppState {
+        let mut state = test_app_state_with_provider_and_memory(provider, memory);
+        state.webhook_secret_hash = webhook_secret_hash;
+        state
+    }
+
     #[test]
     fn security_body_limit_is_64kb() {
         assert_eq!(MAX_BODY_SIZE, 65_536);
@@ -1239,24 +1387,7 @@ mod tests {
 
     #[tokio::test]
     async fn metrics_endpoint_returns_hint_when_prometheus_is_disabled() {
-        let state = AppState {
-            config: Arc::new(Mutex::new(Config::default())),
-            provider: Arc::new(MockProvider::default()),
-            model: "test-model".into(),
-            temperature: 0.0,
-            mem: Arc::new(MockMemory),
-            auto_save: false,
-            webhook_secret_hash: None,
-            pairing: Arc::new(PairingGuard::new(false, &[])),
-            trust_forwarded_headers: false,
-            rate_limiter: Arc::new(GatewayRateLimiter::new(100, 100, 100)),
-            idempotency_store: Arc::new(IdempotencyStore::new(Duration::from_secs(300), 1000)),
-            whatsapp: None,
-            whatsapp_app_secret: None,
-            linq: None,
-            linq_signing_secret: None,
-            observer: Arc::new(crate::observability::NoopObserver),
-        };
+        let state = test_app_state();
 
         let response = handle_metrics(State(state)).await.into_response();
         assert_eq!(response.status(), StatusCode::OK);
@@ -1281,25 +1412,7 @@ mod tests {
             &crate::observability::ObserverEvent::HeartbeatTick,
         );
 
-        let observer: Arc<dyn crate::observability::Observer> = prom;
-        let state = AppState {
-            config: Arc::new(Mutex::new(Config::default())),
-            provider: Arc::new(MockProvider::default()),
-            model: "test-model".into(),
-            temperature: 0.0,
-            mem: Arc::new(MockMemory),
-            auto_save: false,
-            webhook_secret_hash: None,
-            pairing: Arc::new(PairingGuard::new(false, &[])),
-            trust_forwarded_headers: false,
-            rate_limiter: Arc::new(GatewayRateLimiter::new(100, 100, 100)),
-            idempotency_store: Arc::new(IdempotencyStore::new(Duration::from_secs(300), 1000)),
-            whatsapp: None,
-            whatsapp_app_secret: None,
-            linq: None,
-            linq_signing_secret: None,
-            observer,
-        };
+        let state = test_app_state_with_observer(prom);
 
         let response = handle_metrics(State(state)).await.into_response();
         assert_eq!(response.status(), StatusCode::OK);
@@ -1575,6 +1688,39 @@ mod tests {
         }
     }
 
+    #[derive(Default)]
+    struct MockRuntime;
+
+    impl runtime::RuntimeAdapter for MockRuntime {
+        fn name(&self) -> &str {
+            "mock"
+        }
+
+        fn has_shell_access(&self) -> bool {
+            false
+        }
+
+        fn has_filesystem_access(&self) -> bool {
+            false
+        }
+
+        fn storage_path(&self) -> std::path::PathBuf {
+            std::path::PathBuf::from("/tmp/mock-runtime")
+        }
+
+        fn supports_long_running(&self) -> bool {
+            false
+        }
+
+        fn build_shell_command(
+            &self,
+            _command: &str,
+            _workspace_dir: &std::path::Path,
+        ) -> anyhow::Result<tokio::process::Command> {
+            anyhow::bail!("MockRuntime does not support shell commands")
+        }
+    }
+
     #[derive(Default)]
     struct TrackingMemory {
         keys: Mutex<Vec<String>>,
@@ -1642,24 +1788,7 @@ mod tests {
         let provider: Arc<dyn Provider> = provider_impl.clone();
         let memory: Arc<dyn Memory> = Arc::new(MockMemory);
 
-        let state = AppState {
-            config: Arc::new(Mutex::new(Config::default())),
-            provider,
-            model: "test-model".into(),
-            temperature: 0.0,
-            mem: memory,
-            auto_save: false,
-            webhook_secret_hash: None,
-            pairing: Arc::new(PairingGuard::new(false, &[])),
-            trust_forwarded_headers: false,
-            rate_limiter: Arc::new(GatewayRateLimiter::new(100, 100, 100)),
-            idempotency_store: Arc::new(IdempotencyStore::new(Duration::from_secs(300), 1000)),
-            whatsapp: None,
-            whatsapp_app_secret: None,
-            linq: None,
-            linq_signing_secret: None,
-            observer: Arc::new(crate::observability::NoopObserver),
-        };
+        let state = test_app_state_with_provider_and_memory(provider, memory);
 
         let mut headers = HeaderMap::new();
         headers.insert("X-Idempotency-Key", HeaderValue::from_static("abc-123"));
@@ -1700,24 +1829,8 @@ mod tests {
         let tracking_impl = Arc::new(TrackingMemory::default());
         let memory: Arc<dyn Memory> = tracking_impl.clone();
 
-        let state = AppState {
-            config: Arc::new(Mutex::new(Config::default())),
-            provider,
-            model: "test-model".into(),
-            temperature: 0.0,
-            mem: memory,
-            auto_save: true,
-            webhook_secret_hash: None,
-            pairing: Arc::new(PairingGuard::new(false, &[])),
-            trust_forwarded_headers: false,
-            rate_limiter: Arc::new(GatewayRateLimiter::new(100, 100, 100)),
-            idempotency_store: Arc::new(IdempotencyStore::new(Duration::from_secs(300), 1000)),
-            whatsapp: None,
-            whatsapp_app_secret: None,
-            linq: None,
-            linq_signing_secret: None,
-            observer: Arc::new(crate::observability::NoopObserver),
-        };
+        let mut state = test_app_state_with_provider_and_memory(provider, memory);
+        state.auto_save = true;
 
         let headers = HeaderMap::new();
 
@@ -1770,24 +1883,11 @@ mod tests {
         let memory: Arc<dyn Memory> = Arc::new(MockMemory);
         let secret = generate_test_secret();
 
-        let state = AppState {
-            config: Arc::new(Mutex::new(Config::default())),
+        let state = test_app_state_with_provider_memory_and_secret(
             provider,
-            model: "test-model".into(),
-            temperature: 0.0,
-            mem: memory,
-            auto_save: false,
-            webhook_secret_hash: Some(Arc::from(hash_webhook_secret(&secret))),
-            pairing: Arc::new(PairingGuard::new(false, &[])),
-            trust_forwarded_headers: false,
-            rate_limiter: Arc::new(GatewayRateLimiter::new(100, 100, 100)),
-            idempotency_store: Arc::new(IdempotencyStore::new(Duration::from_secs(300), 1000)),
-            whatsapp: None,
-            whatsapp_app_secret: None,
-            linq: None,
-            linq_signing_secret: None,
-            observer: Arc::new(crate::observability::NoopObserver),
-        };
+            memory,
+            Some(Arc::from(hash_webhook_secret(&secret))),
+        );
 
         let response = handle_webhook(
             State(state),
@@ -1812,24 +1912,11 @@ mod tests {
         let valid_secret = generate_test_secret();
         let wrong_secret = generate_test_secret();
 
-        let state = AppState {
-            config: Arc::new(Mutex::new(Config::default())),
+        let state = test_app_state_with_provider_memory_and_secret(
             provider,
-            model: "test-model".into(),
-            temperature: 0.0,
-            mem: memory,
-            auto_save: false,
-            webhook_secret_hash: Some(Arc::from(hash_webhook_secret(&valid_secret))),
-            pairing: Arc::new(PairingGuard::new(false, &[])),
-            trust_forwarded_headers: false,
-            rate_limiter: Arc::new(GatewayRateLimiter::new(100, 100, 100)),
-            idempotency_store: Arc::new(IdempotencyStore::new(Duration::from_secs(300), 1000)),
-            whatsapp: None,
-            whatsapp_app_secret: None,
-            linq: None,
-            linq_signing_secret: None,
-            observer: Arc::new(crate::observability::NoopObserver),
-        };
+            memory,
+            Some(Arc::from(hash_webhook_secret(&valid_secret))),
+        );
 
         let mut headers = HeaderMap::new();
         headers.insert(
@@ -1859,24 +1946,11 @@ mod tests {
         let memory: Arc<dyn Memory> = Arc::new(MockMemory);
         let secret = generate_test_secret();
 
-        let state = AppState {
-            config: Arc::new(Mutex::new(Config::default())),
+        let state = test_app_state_with_provider_memory_and_secret(
             provider,
-            model: "test-model".into(),
-            temperature: 0.0,
-            mem: memory,
-            auto_save: false,
-            webhook_secret_hash: Some(Arc::from(hash_webhook_secret(&secret))),
-            pairing: Arc::new(PairingGuard::new(false, &[])),
-            trust_forwarded_headers: false,
-            rate_limiter: Arc::new(GatewayRateLimiter::new(100, 100, 100)),
-            idempotency_store: Arc::new(IdempotencyStore::new(Duration::from_secs(300), 1000)),
-            whatsapp: None,
-            whatsapp_app_secret: None,
-            linq: None,
-            linq_signing_secret: None,
-            observer: Arc::new(crate::observability::NoopObserver),
-        };
+            memory,
+            Some(Arc::from(hash_webhook_secret(&secret))),
+        );
 
         let mut headers = HeaderMap::new();
         headers.insert("X-Webhook-Secret", HeaderValue::from_str(&secret).unwrap());
-- 
2.51.0

